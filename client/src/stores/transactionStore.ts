import { create } from 'zustand';
import axios from 'axios';
import {
  Transaction,
  PaginationState,
  TransactionFilters,
  PaginatedResponse,
} from '../types';
import { useFilterStore } from './filterStore'; // Import filter store

interface TransactionState {
  transactions: Transaction[];
  pagination: PaginationState;
  isLoading: boolean;
  error: string | null;
  // Report specific state
  reportData: Transaction[] | null;
  isGeneratingReport: boolean;
  reportError: string | null;
  // State for logging
  isLogging: boolean;
  logError: string | null;
  logSuccess: boolean; // Flag for success feedback
}

// Type for data needed to create a new transaction
// Matches the expected body for POST /api/transactions
// Excludes fields generated by the server/db (id, createdAt, createdById)
export interface LogTransactionData {
  transactionType: string;
  amount: number; // Ensure this is handled as a number
  currency: string;
  accountId: string;
  transactionTimestamp: string; // Send as ISO string
  description?: string;
  sourceSystem?: string;
}

interface TransactionActions {
  fetchTransactions: () => Promise<void>;
  logTransaction: (data: LogTransactionData) => Promise<boolean>; // Returns true on success, false on error
  generateReport: () => Promise<void>; // Action to fetch all data for report
  clearReport: () => void;
  setCurrentPage: (page: number) => void;
  setPageSize: (size: number) => void;
  resetLogStatus: () => void; // To clear success/error messages
}

const initialPagination: PaginationState = {
  currentPage: 1,
  pageSize: 25, // Default page size
  totalCount: 0,
};

// Helper to remove undefined/null/empty string values from an object
const cleanFilters = (
  filters: TransactionFilters
): Record<string, string | number> => {
  return Object.entries(filters).reduce(
    (acc: Record<string, string | number>, [key, value]) => {
      // Ensure value is not undefined, null, or an empty string before adding
      // Also explicitly check for number type for amount filters
      if (value !== undefined && value !== null && value !== '') {
        // We know TransactionFilters values are string or number | undefined
        // So after the null/undefined/empty check, they must be string or number
        acc[key] = value as string | number;
      }
      return acc;
    },
    {} // Initial value is an empty object, type inference works here
  );
};

export const useTransactionStore = create<
  TransactionState & TransactionActions
>((set, get) => ({
  transactions: [],
  pagination: initialPagination,
  isLoading: false,
  error: null,
  // Report initial state
  reportData: null,
  isGeneratingReport: false,
  reportError: null,
  // Logging initial state
  isLogging: false,
  logError: null,
  logSuccess: false,

  fetchTransactions: async () => {
    set({ isLoading: true, error: null });
    const { currentPage, pageSize } = get().pagination;
    // Get filters directly from the filterStore
    const filters = useFilterStore.getState().filters;
    const cleanedFilters = cleanFilters(filters);

    try {
      const params = {
        ...cleanedFilters,
        page: currentPage,
        limit: pageSize,
      };

      // Ensure Authorization header is set if token exists (from authStore)
      // This assumes axios defaults are set correctly by authStore
      const response = await axios.get<PaginatedResponse<Transaction>>(
        '/api/transactions',
        { params }
      );

      const { data, totalCount } = response.data;

      set({
        transactions: data,
        pagination: { ...get().pagination, totalCount },
        isLoading: false,
      });
    } catch (err) {
      let errorMessage = 'Failed to fetch transactions.';
      if (axios.isAxiosError(err) && err.response) {
        errorMessage =
          err.response.data?.message ||
          err.response.data?.error ||
          errorMessage;
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }
      console.error('Fetch transactions error:', err);
      set({ error: errorMessage, isLoading: false, transactions: [] });
      // Optionally reset pagination on error?
      // set({ pagination: { ...get().pagination, totalCount: 0 } });
    }
  },

  setCurrentPage: (page) => {
    set((state) => ({
      pagination: { ...state.pagination, currentPage: page },
    }));
    // Fetch data for the new page
    get().fetchTransactions();
  },

  setPageSize: (size) => {
    set((state) => ({
      // Reset to page 1 when page size changes
      pagination: { ...state.pagination, pageSize: size, currentPage: 1 },
    }));
    // Fetch data with the new page size
    get().fetchTransactions();
  },

  generateReport: async () => {
    set({ isGeneratingReport: true, reportError: null, reportData: null });
    // Get filters directly from the filterStore
    const filters = useFilterStore.getState().filters;
    const cleanedFilters = cleanFilters(filters);

    try {
      // Ensure Authorization header is set if token exists (from authStore)
      // This assumes axios defaults are set correctly by authStore
      // The /api/reports endpoint returns ALL matching transactions (no pagination)
      const response = await axios.get<Transaction[]>('/api/reports', {
        params: cleanedFilters,
      });

      set({
        reportData: response.data,
        isGeneratingReport: false,
      });
    } catch (err) {
      let errorMessage = 'Failed to generate report.';
      if (axios.isAxiosError(err) && err.response) {
        errorMessage =
          err.response.data?.message ||
          err.response.data?.error ||
          errorMessage;
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }
      console.error('Generate report error:', err);
      set({ reportError: errorMessage, isGeneratingReport: false });
    }
  },

  clearReport: () => {
    set({ reportData: null, reportError: null, isGeneratingReport: false });
  },

  logTransaction: async (data: LogTransactionData) => {
    set({ isLogging: true, logError: null, logSuccess: false });
    try {
      // Ensure Authorization header is set if token exists (from authStore)
      // This assumes axios defaults are set correctly elsewhere
      await axios.post('/api/transactions', data);

      set({ isLogging: false, logSuccess: true });
      // Optionally: Refetch transactions on the current page after successful logging
      // get().fetchTransactions();
      return true; // Indicate success
    } catch (err) {
      let errorMessage = 'Failed to log transaction.';
      if (axios.isAxiosError(err) && err.response) {
        errorMessage =
          err.response.data?.message ||
          err.response.data?.error ||
          errorMessage;
      } else if (err instanceof Error) {
        errorMessage = err.message;
      }
      console.error('Log transaction error:', err);
      set({ logError: errorMessage, isLogging: false, logSuccess: false });
      return false; // Indicate failure
    }
  },

  resetLogStatus: () => {
    set({ logError: null, logSuccess: false, isLogging: false });
  },
}));

// Optional: Subscribe to filter changes to automatically refetch
// This connects transactionStore updates to filterStore updates.
useFilterStore.subscribe((state, prevState) => {
  // Simple equality check; consider deep equality if filters are complex objects
  if (JSON.stringify(state.filters) !== JSON.stringify(prevState.filters)) {
    console.log('Filters changed, refetching transactions...');
    // Reset to page 1 when filters change
    useTransactionStore.setState((state) => ({
      pagination: { ...state.pagination, currentPage: 1 },
    }));
    useTransactionStore.getState().fetchTransactions();
  }
});
