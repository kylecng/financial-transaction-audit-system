import prisma from '../utils/prisma';
import {
  Transaction,
  TransactionFilters,
  User,
  PaginatedResponse,
} from '../types';
import { Decimal } from '@prisma/client/runtime/library';
import { Prisma } from '@prisma/client'; // Import Prisma namespace for types

// Define the input type for creating a transaction, excluding fields generated by the DB or derived from context
// Include createdById which comes from the authenticated user
type CreateTransactionInput = Omit<Transaction, 'id' | 'createdAt'> & {
  createdById: number;
  // Ensure amount is handled correctly, Prisma expects Decimal
  amount: number | Decimal;
  // Ensure transactionTimestamp is handled correctly, Prisma expects DateTime
  transactionTimestamp: Date | string;
};

/**
 * Creates a new transaction in the database.
 * @param transactionData - The data for the new transaction.
 * @param userId - The ID of the user creating the transaction.
 * @returns The newly created transaction object.
 * @throws Throws an error if the database operation fails.
 */
export const createTransaction = async (
  transactionData: Omit<CreateTransactionInput, 'createdById'>,
  userId: number
): Promise<Transaction> => {
  try {
    // Prisma expects Decimal for amount, ensure conversion if needed
    // Prisma expects DateTime for transactionTimestamp, ensure conversion if needed
    const newTransaction = await prisma.transaction.create({
      data: {
        ...transactionData,
        amount: new Decimal(transactionData.amount), // Convert number to Decimal
        transactionTimestamp: new Date(transactionData.transactionTimestamp), // Convert string/Date to Date
        createdById: userId,
        // createdAt is handled by @default(now()) in Prisma schema
      },
    });

    // Convert Decimal back to number for the return type if necessary,
    // although the Transaction type defines amount as number.
    // Prisma client might return Decimal, so explicit conversion might be needed depending on strictness.
    return {
      ...newTransaction,
      amount: newTransaction.amount.toNumber(),
    };
  } catch (error) {
    console.error('Error creating transaction:', error);
    // Re-throw the error to be handled by the route handler
    throw new Error('Failed to create transaction in database.');
  }
};

/**
 * Fetches all transactions matching the specified filters for reporting purposes.
 * This function does not apply pagination and assumes auditor access (no user-specific filtering).
 * @param filters - The filtering criteria.
 * @returns An array of all matching transaction objects.
 * @throws Throws an error if the database operation fails.
 */
export const getReportTransactions = async (
  filters: TransactionFilters
): Promise<Transaction[]> => {
  const {
    transactionType,
    accountId,
    startDate,
    endDate,
    minAmount,
    maxAmount,
    keyword,
    createdById,
  } = filters;

  // Construct the base 'where' clause for Prisma query
  const where: Prisma.TransactionWhereInput = {};

  // Apply query parameter filters (Auditors see all, so no user.id filter by default)
  if (createdById) {
    // Allow auditors to filter by specific user ID if provided
    where.createdById = createdById;
  }
  if (transactionType) {
    where.transactionType = { contains: transactionType, mode: 'insensitive' };
  }
  if (accountId) {
    where.accountId = { contains: accountId, mode: 'insensitive' };
  }
  if (startDate || endDate) {
    where.transactionTimestamp = {};
    if (startDate) {
      try {
        where.transactionTimestamp.gte = new Date(startDate);
      } catch (e) {
        console.error('Invalid start date format:', startDate);
        // Consider throwing a specific error or handling differently
      }
    }
    if (endDate) {
      try {
        const endOfDay = new Date(endDate);
        endOfDay.setHours(23, 59, 59, 999);
        where.transactionTimestamp.lte = endOfDay;
      } catch (e) {
        console.error('Invalid end date format:', endDate);
        // Consider throwing a specific error or handling differently
      }
    }
  }
  if (minAmount !== undefined || maxAmount !== undefined) {
    where.amount = {};
    if (minAmount !== undefined) {
      try {
        where.amount.gte = new Decimal(minAmount);
      } catch (e) {
        console.error('Invalid min amount format:', minAmount);
        // Consider throwing a specific error or handling differently
      }
    }
    if (maxAmount !== undefined) {
      try {
        where.amount.lte = new Decimal(maxAmount);
      } catch (e) {
        console.error('Invalid max amount format:', maxAmount);
        // Consider throwing a specific error or handling differently
      }
    }
  }
  if (keyword) {
    where.OR = [
      { description: { contains: keyword, mode: 'insensitive' } },
      { sourceSystem: { contains: keyword, mode: 'insensitive' } },
      { accountId: { contains: keyword, mode: 'insensitive' } },
      { transactionType: { contains: keyword, mode: 'insensitive' } },
    ];
  }

  try {
    // Fetch all matching transactions, ordered by timestamp
    const transactions = await prisma.transaction.findMany({
      where,
      orderBy: {
        transactionTimestamp: 'desc',
      },
    });

    // Convert Decimal amounts to numbers for the response
    const formattedTransactions = transactions.map((tx) => ({
      ...tx,
      amount: tx.amount.toNumber(),
    }));

    return formattedTransactions;
  } catch (error) {
    console.error('Error fetching report transactions:', error);
    // Re-throw the error to be handled by the route handler
    throw new Error('Failed to fetch report transactions from database.');
  }
};

// Interface for pagination parameters
interface PaginationParams {
  page: number;
  pageSize: number;
}

/**
 * Fetches transactions based on filters, pagination, and user role.
 * @param filters - The filtering criteria.
 * @param pagination - The pagination parameters (page, pageSize).
 * @param user - The authenticated user object ({ id, role }).
 * @returns A paginated response containing transactions and the total count.
 * @throws Throws an error if the database operation fails.
 */
export const getTransactions = async (
  filters: TransactionFilters,
  pagination: PaginationParams,
  user: User
): Promise<PaginatedResponse<Transaction>> => {
  const { page, pageSize } = pagination;
  const {
    transactionType,
    accountId,
    startDate,
    endDate,
    minAmount,
    maxAmount,
    keyword,
    createdById, // Add createdById filter
  } = filters;

  // Construct the base 'where' clause for Prisma query
  const where: Prisma.TransactionWhereInput = {};

  // Apply role-based filtering AND specific filters
  if (user.role === 'transactor') {
    where.createdById = user.id; // Transactors ONLY see their own
  } else if (user.role === 'auditor' && createdById) {
    // Auditors can optionally filter by createdById if provided
    where.createdById = createdById;
  }
  // If auditor and createdById is not provided, no user filter is applied (sees all)

  // Apply other query parameter filters
  if (transactionType) {
    where.transactionType = { contains: transactionType, mode: 'insensitive' };
  }
  if (accountId) {
    where.accountId = { contains: accountId, mode: 'insensitive' };
  }
  if (startDate || endDate) {
    where.transactionTimestamp = {};
    if (startDate) {
      // Ensure valid date format before creating Date object
      try {
        where.transactionTimestamp.gte = new Date(startDate);
      } catch (e) {
        console.error(
          'Invalid start date format:',
          startDate
        ); /* Handle error appropriately */
      }
    }
    if (endDate) {
      // Adjust endDate to include the whole day
      try {
        const endOfDay = new Date(endDate);
        endOfDay.setHours(23, 59, 59, 999);
        where.transactionTimestamp.lte = endOfDay;
      } catch (e) {
        console.error(
          'Invalid end date format:',
          endDate
        ); /* Handle error appropriately */
      }
    }
  }
  if (minAmount !== undefined || maxAmount !== undefined) {
    where.amount = {};
    if (minAmount !== undefined) {
      try {
        where.amount.gte = new Decimal(minAmount);
      } catch (e) {
        console.error(
          'Invalid min amount format:',
          minAmount
        ); /* Handle error appropriately */
      }
    }
    if (maxAmount !== undefined) {
      try {
        where.amount.lte = new Decimal(maxAmount);
      } catch (e) {
        console.error(
          'Invalid max amount format:',
          maxAmount
        ); /* Handle error appropriately */
      }
    }
  }
  if (keyword) {
    where.OR = [
      { description: { contains: keyword, mode: 'insensitive' } },
      { sourceSystem: { contains: keyword, mode: 'insensitive' } },
      // Add other fields to search if needed, e.g., accountId, transactionType
      { accountId: { contains: keyword, mode: 'insensitive' } },
      { transactionType: { contains: keyword, mode: 'insensitive' } },
    ];
  }

  // Calculate skip value for pagination
  const skip = (page - 1) * pageSize;

  try {
    // Fetch the paginated data and the total count concurrently
    const [transactions, totalCount] = await prisma.$transaction([
      prisma.transaction.findMany({
        where,
        skip,
        take: pageSize,
        orderBy: {
          transactionTimestamp: 'desc',
        },
      }),
      prisma.transaction.count({
        where,
      }),
    ]);

    // Convert Decimal amounts to numbers for the response
    const formattedTransactions = transactions.map((tx) => ({
      ...tx,
      amount: tx.amount.toNumber(),
    }));

    return {
      data: formattedTransactions,
      totalCount,
    };
  } catch (error) {
    console.error('Error fetching transactions:', error);
    // Re-throw the error to be handled by the route handler
    throw new Error('Failed to fetch transactions from database.');
  }
};
